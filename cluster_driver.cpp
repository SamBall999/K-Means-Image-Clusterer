
#include <iostream> 
#include <fstream>
#include <sstream> 
#include <vector>
#include <cmath>
#include <string>
#include "clusterer.h"


//command line, as follows: clusterer <dataset> [-o output] [-k n] [-bin b]

// dataset is the location of the folder that contains the images to be clustered.


//three optional command line arguments:
/*1. [-o output]: This is the name of the file that your program will write to. If no output
file is supplied, the program should default to writing the final clusterings to std:cout
2. [-k n]: This is the number of clusters to be generated by the K-means algorithm. It
should default to 10.
3. [-bin b]: This parameter specifies the width of your histogram feature. It should
default to 1.*/

//parse command line parameters
int main(int argc, char* argv[])
{
    //get file names
    std::string data_folder = std::string(argv[1]); 
    
    std::string output_name = "";
    int no_clusters = 10; //set default 
    float bin_width = 1; //set default
    bool colour_flag = false;
    bool two_dim_flag = false;
    bool three_dim_flag = false;
    bool shape_flag = false;

    //check for additional arguments
    if(argc > 1)
    {
        for(int i = 2; i < argc; i+=2)
        {
            //NB check flags 
            switch(std::string(argv[i]).at(1))
            {
                case 'o': 
                {
                      output_name = std::string(argv[i+1]);
                      //std::cout << output_name << std::endl;
                      break;
                }

                case 'k':  
                {
                     //std::cout << argv[i+1] << std::endl;
                    no_clusters = stoi(std::string(argv[i+1]));
                    break;
                }

                case 'b': 
                {
                    //std::cout << argv[i+1] << std::endl;
                    if(std::string(argv[i]) == "-bin") //check that valid option entered
                    {
                        bin_width = stof(std::string(argv[i+1])); //must this be bin not b??
                    }
                    break;
                }
                 case 'c': 
                {
                    //std::cout << argv[i] << std::endl;
                    if(std::string(argv[i]) == "-color") //check that valid option entered
                    {
                        colour_flag = true; //must this be colour not c?
                        //std::cout << "Use colour histograms" << std::endl;
                    }
                    break;
                }
                 case 't': 
                {
                    //std::cout << argv[i] << std::endl;
                    if(std::string(argv[i]) == "-two_dim") //check that valid option entered
                    {
                        two_dim_flag = true; //must this be colour not c?
                        //std::cout << "Use colour histograms" << std::endl;
                    }
                    else if(std::string(argv[i]) == "-three_dim") //check that valid option entered
                    {
                        three_dim_flag = true; //must this be colour not c?
                        //std::cout << "Use colour histograms" << std::endl;
                    }
                    break;
                }
                  case 's': 
                {
                    //std::cout << argv[i] << std::endl;
                    if(std::string(argv[i]) == "-shape") //check that valid option entered
                    {
                        shape_flag = true; //must this be colour not c?
                        //std::cout << "Use colour histograms" << std::endl;
                    }
                    break;
                }
                
            }
        }
       

    }

    std::cout << "\nCHOSEN PARAMETERS" << std::endl;
    std::cout << "Data Folder: " << data_folder << std::endl;
    std::cout << "Output File: " << output_name << std::endl;
    std::cout << "No. of Clusters: " << no_clusters << std::endl;
    std::cout << "Bin Width: " << bin_width << std::endl;
    std::cout << "Colour Histograms: " << colour_flag << std::endl;
    std::cout << "\n" << std::endl;



    std::string output_file_name = output_name + ".txt";
    //delete output file if it exists
      if (std::remove(output_file_name.c_str()) != 0)
     {
		//std::cout << "File does not exist" << std::endl;
     }


    if(colour_flag==true)
    {
         //read in images and get image features
        BLLSAM009::Colour_Feature col;
        int size = col.read_images(data_folder);
        col.get_colour_images(size);
        int hist_size = col.get_image_features(bin_width, size);
        std::cout << "Hist Size: " << hist_size << std::endl;

        //k means
        BLLSAM009::Clusterer c(col); //pass in greyscale feature
        c.k_means(no_clusters, hist_size*3); //hist_size??

         //write to output file
        std::ofstream out_file(output_file_name);
        out_file << c << std::endl;

    }
    else if (two_dim_flag == true)
    {
          //read in images and get image features
        BLLSAM009::Two_D_Feature t;
        int size = t.read_images(data_folder);
        t.get_colour_images(size);
        int hist_size = t.get_image_features(bin_width, size); //Returns hist_size*hist_size*3 because R and B, B and G, G and R
        std::cout << "Hist Size: " << hist_size << std::endl;

        //k means
        BLLSAM009::Clusterer c(t); //pass in greyscale feature
        c.k_means(no_clusters, hist_size); //NO x3

         //write to output file
        std::ofstream out_file(output_file_name);
        out_file << c << std::endl;

    }
    else if (three_dim_flag == true)
    {
          //read in images and get image features
        BLLSAM009::Three_D_Feature t;
        int size = t.read_images(data_folder);
        t.get_colour_images(size);
        std::cout << "Colour images done" << std::endl;
        int hist_size = t.get_image_features(bin_width, size); //Returns hist_size*hist_size*3 because R and B, B and G, G and R
        std::cout << "Hist Size: " << hist_size << std::endl;

        //k means
        BLLSAM009::Clusterer c(t); //pass in greyscale feature
        c.k_means(no_clusters, hist_size); //NO x3

         //write to output file
        std::ofstream out_file(output_file_name);
        out_file << c << std::endl;

    }
    else if (shape_flag == true)
    {
         {
          //read in images and get image features
        BLLSAM009::Shape_Feature s;
        int size = s.read_images(data_folder);
        s.get_colour_images(size);
        s.get_image_centres(size);
        std::cout << "Image centres done" << std::endl;
        int hist_size = s.get_image_features(bin_width, size); //Returns hist_size*hist_size*3 because R and B, B and G, G and R
        std::cout << "Hist Size: " << hist_size << std::endl;

          
        //k means
        BLLSAM009::Clusterer c(s); //pass in greyscale feature
        c.k_means(no_clusters, hist_size*3); //make it standaridised whether this is x3 or not

         //write to output file
        std::ofstream out_file(output_file_name);
        out_file << c << std::endl;

    }
    }
    else 
    {
        //read in images and get image features
        BLLSAM009::Grey_Feature g;
        int size = g.read_images(data_folder);
        g.convert_to_grey(size);
        int hist_size = g.get_image_features(bin_width, size);

        //k means
        BLLSAM009::Clusterer c(g); //pass in greyscale feature


        //c.k_meansplusplus_init(no_clusters, hist_size);
        //std::cout << "Hist Size: " << hist_size << std::endl;
        c.k_means(no_clusters, hist_size);

         //write to output file
        std::ofstream out_file(output_file_name);
        out_file << c << std::endl;
    }



    //clean up memory in the destructor??
    //delete c; //clean up
    
    
    return 0;

}